# Медианный фильтр
Лабораторная работа выполнена на c++, в среде программирования Visual Studio, на домашнем ПК.

# Алгоритм
 1. Считается необходимое количество потоков и блоков. Общее число потоков >= кол-ву элементов входной матрицы.
 2. Каждый поток "выбирает" пиксель изображения исходя из своих глобальных индексов на сетке.
 3. Каждый поток загружает в свой сегмент разделяемой памяти своего блока элементы матрицы вокруг своего элемента в соответсвии с заданным размером фильтра из текстурной памяти.
 Если фильтр выходит за границы матрицы в текстурной памяти, то вместо него в буфер НЕ кладется какое-либо число, несуществующий элемент просто игнорируется (чтобы не искажать значение медианы).
 4. Далее этот сегмент разделяемой памяти сортируется с помощью пузырьковой сортировки
 5. В результирующую матрицу кладется медиана отсортированного сегмента


# Размеры блока и грида
Выбрана 2D топология блоков и их сетки, поскольку в таком случае алгоритм становится интуитивно понятным.
Размеры блока и сетки выбираются автоматически исходя из разрешенных пределов и скорости выполнения, с учетом того, что может быть выбран больший размер фильтра,
от размера которого зависит размер разделенной памяти.

# Оптимизации
В первой версии парарллельной программы присутсвовали некоторые ее части, которые хотелось изменить, чтобы ускорить программу.

Изначально каждый поток имел собственный буфер, память для которого он выделял во время работы. Оказалось, что на выделение памяти тратится почти все время работы потоков,
более того, память выделяется в глобальной памяти GPU, доступ к которой является самым медленным.
Поэтому было принято решение отказаться от нее и использовать разделяемую память блока, доступ к которой быстрее, и которая выделяется оди раз при выполнении блока потоков.
Это позволило ускорить программу более чем в 40 раз (до оптимизаций время работы параллельной программы было примерно в 2 раза больше, чем для последовательной).

Также изначально был использован тип int для хранения данных, но, поскольку работа ведется с ч/б изображениями, целесообразным стоит считать использование типа unsigned char(0-255).
Это позволило ускорить параллельный алгоритм чуть менее чем в 2 раза.

Также были применены другие мелкие оптимизации кода.


# Эксперименты  1
Для тестирования работы программы была выбрана картинка грибов.
На изображение был наложен шум соли и перца, 10% пикселей изображения были подвержены искажению.

Исходное черно-бело изображение
![грибы чб](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/mushroom_grayscale.png?raw=true)

Изображение с шумом
![грибы чб шум](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/image_with_noise.png?raw=true)

Изображение, отфильтрованное последовательной программой
![грибы чб отфильрованное cpu](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/image_filtered_cpu.png?raw=true)

Изображение, отфильтрованное параллельной программой
![грибы чб отфильрованное gpu](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/image_filtered_gpu.png?raw=true)

# Эксперименты 2
Для проведения экспериментов со сревнением времени выполнения параллельной и последовательных программ была создана функция, которая генерирует изображение с заданными высотой и шириной.
Размеры изображений были выбраны в соответсвии с основными использующимися разрешениями. (HD, FullHd, 2K, 4K)

Время представлено усредненное по 36 запускам. 

Характеристики ПК
Процессор 			| intel core i7-13700K
------------------- | ----------------------------------------------
Количество ядер		| 16
------------------- | ----------------------------------------------
Количество потоков 	| 24
------------------- | ----------------------------------------------
Оперативная память 	| 32 ГБ DDR5
------------------- | ----------------------------------------------
Видеокарта			| NVIDIA GTX 1650
------------------- | ----------------------------------------------
Тип системы	Windows | 10


Для сравнения времени выполнения в зависимости от размера изображения был использован фильтр 3 х 3.

Размер изображения  | Время выполнения GPU, мс 	| Время выполнения CPU, мс 	| Ускорение
------------------- | -------------------------	| ------------------------- | ----------
1280 × 720  	   	| 6,8    					| 236						| 34,7
1920 × 1080 		| 13,8    					| 550						| 39,85
2560 × 1440	   		| 23,6    					| 959						| 40,63
3840 × 2160  		| 44,3	   					| 2141						| 48,32

![время от разрешения, сравнение](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/resolution_compare.png?raw=true)
![время от разрешения, ускорение](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/resolution_acceleration.png?raw=true)

Из графика и таблиы видно, что как для последовательной программы, так и для параллельной время увеличивается примерно в 2 раза с каждым шагом, что ожидаемо,
поскольку общее количество элементов с каждым увеличением разрешения становится примерно в 2 раза больше. Тем не менее, рост времни выполнения с ростом разрешения у параллельной программы замедляется.
Можно сделать предположение о том, что рост ускорения параллельной программы обусловлен использвоанием текстурной памяти, получение рядом стоящих элементов из которой кешируется, что должно быть более заметно с ростом количества обращений к ней.


Для сравнения времени выполнения в зависимости от размера фильтра был выбран размер изображения 1920 × 1080.

Размер фильтра  | Время выполнения GPU, мс 	| Время выполнения CPU, мс | Ускорение
--------------- | -------------------------	| ------------------------ | ----------
3 × 3  			| 13,8    					| 550                      | 39,85
5 × 5 			| 64,5    					| 1'866                    | 28,93
7 × 7	   		| 220,3    					| 4'025                    | 18,27
9 × 9  			| 751,5						| 7'130                    | 9,48

![время от фильтра, сравнение](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/filter_compare.png?raw=true)
![время от фильтра, ускорение](https://github.com/VadimKolodin/hpc/tree/main/median%20filter/filter_acceleration.png?raw=true)

Для таблицы графика, отражающей зависимость времени выоплнения от размера фильтра, видно, что время выполнения растет быстрее, чем размер фильтра.
Данное являение сильнее заметно для параллельной программы. Это обусловлено тремя факторами:
1. Каждый поток выполняет больше операций, при неизменном количестве потоков, что увеличивает время обработки.
2. С увеличением размера фильтра увеличивается количество элементов сортировки, которая предполагает большое количество ветвлений (if), 
а поскольку варпы (пачки в 32 потока) выполняются физически одновременно, то всем потокам придется ждать один, если он зайдет внутрь if'a (то есть будет менять местами элементы), что сильно замедляет работу всех потоков.
3. Ускорение, получаемое за счет использования текстурной памяти нивелируется пунктами 1 и 2, что не дает получить желаемое быстрое выполнение параллельной программы.

В итоге можно сказать, что использование графического процессора при обработке медианным фильтром оправдано.
При этом, чем больше будет обрабатываемое изображение и чем меньше будет размер фильтра, тем эффективнее будет работа параллельной прграммы на графическом процссоре.
Тем не менее, для относительно небольших фильтров (до, наверное, 7 × 7) получено приемлимое ускорение, которое можно увеличить, избавишись от ветвлений при сортировке, используя, например,
сортировочные сети. Для больших же фильтров, где ускорение не такое большое и избежать медленной сортировки трудно, искажение зашумленного изображения будет слишком сильно, что ставит под вопрос целесообразонсть использования таких больших фильтров впринципе.
